#!/usr/bin/env sh

# This script is intended to be used from the archiso.

### HELPERS ###

end() {
  printf '%s\n' "$1" >&2 && exit 1 # log to stderr and exit with failure
}

install() {
  pacman --noconfirm --needed -S "$1" >/dev/null 2>&1
}

welcome() {
  gum confirm --prompt.foreground 99 --prompt.border-foreground 105 --prompt.width 55 \
    --prompt.margin "1 2" --prompt.padding "1 2" --prompt.border double \
    --prompt.align center --affirmative "Continue" --negative "End" \
    --default "Welcome to irisfield's Arch Linux guided installer.
This script installs a minimal Arch Linux system."
}

get_username() {
  username=$(gum input --prompt.foreground 99 --prompt.bold --prompt "Account name: " \
    --placeholder "(enter a name for the user account)")
  while ! echo "$username" | grep -q "^[a-z_][a-z0-9_-]*$"; do
    username=$(gum input --prompt.foreground 99 --prompt.bold \
      --prompt "Try again. Account name: " \
      --placeholder "(only lowercase letters, - and _ are allowed)")
  done
}

get_password() {
  password=$(gum input --prompt.foreground 99 --prompt.bold --prompt "Password: " \
    --password --placeholder "(enter a password for $username)")
  verify=$(gum input --prompt.foreground 99 --prompt.bold --prompt "Verify: " \
    --password --placeholder "(retype the password)")
  while [ -z "$password" ] || [ "$password" != "$verify" ]; do
    unset verify
    password=$(gum input --prompt.foreground 99 --prompt.bold \
      --prompt "Try again. Password: " --password \
      --placeholder "(enter a password for $username)")
    verify=$(gum input --prompt.foreground 99 --prompt.bold --prompt "Verify: " \
      --password --placeholder "(retype the password)")
  done
}

get_hostname() {
  hostname=$(gum input --prompt.foreground 99 --prompt.bold --prompt "Hostname: " \
    --placeholder "(enter a name for the host)")
  while ! echo "$hostname" | grep -q "^[a-z_][a-z0-9_-]*$"; do
    hostname=$(gum input --prompt.foreground 99 --prompt.bold \
      --prompt "Try again. Hostname: " \
      --placeholder "(only lowercase letters, - and _ are allowed)")
  done
}

set_keymap() {
  keymap=""
  while [ -z "$keymap" ]; do
    # choose a keymap
    keymap=$(localectl list-keymaps --no-pager | gum filter --prompt.foreground 93 \
      --prompt.bold --prompt "Keymap: " --placeholder "(search for your keyboard layout)")
  done
  # load the selected keymap
  loadkeys "$keymap"
}

get_timezone() {
  timezone=""
  while [ -z "$timezone" ]; do
    # choose a timezone
    timezone=$(timedatectl list-timezones --no-pager | gum filter --prompt.foreground 93 \
      --prompt.bold --prompt "Timezone: " --placeholder "(search for your timezone)")
  done
  # synchronize the network time protocol
  timedatectl set-ntp true
  # display status
  timedatectl status
}

disk_partition() {
  diskname=""
  while [ -z "$diskname" ]; do
    # choose the disk to partition
    diskname=$(lsblk -Alpn -o NAME,SIZE,TYPE | grep 'disk' | gum filter \
      --prompt.foreground 93 --prompt.bold --prompt "Disk name: " \
      --placeholder "(select the disk to partition)" | cut -d' ' -f1)
  done
  # nvme drives uses the 'p' label for the partition
  label=$(echo "$diskname" | grep -q "nvme" && printf '%s' "p")
  # show the recommended layout and prompt the user
  gum confirm --prompt.foreground 99 --prompt.border-foreground 105 \
    --prompt.margin "1 2" --prompt.padding "1 2" --prompt.border thick \
    --prompt.align center --negative "Skip" \
    --default "$(gum format -t markdown "# Recommended Partition Layout
Mountpoint|Partition|ID Type|Suggested Size
-|-|-|-
/mnt/boot|${diskname}${label}1|ef EFI|512 MiB
/mnt|${diskname}${label}2|83 Linux|Remaining size")

Only an EFI and root partition are required.
You may also opt to partition the disk in any other way.
$(gum style --align center --bold --foreground 69 \
'Would you like to partition the disk?')" && unset label && cfdisk "$diskname"
  # make sure the disk has been partitioned
  if ! lsblk -Alpn -o NAME,SIZE,TYPE | grep "${diskname##*/}.*part"; then
    end "no partitions found, please partition your disk before quitting cfdisk"
  fi
}

get_efi_partition() {
  efipartition=""
  while [ -z "$efipartition" ]; do
    # choose the name of the EFI partition
    efipartition=$(lsblk -Alpn -o NAME,SIZE,TYPE | grep "${diskname##*/}.*part" | \
      gum filter --prompt.foreground 93 --prompt.bold --prompt "EFI partition: " \
        --placeholder "(select the EFI partition)" | cut -d' ' -f1)
  done &&
  # confirm whether or not to format the efi partition
  gum confirm --prompt.foreground 99 --prompt.border-foreground 105 --prompt.width 55 \
    --prompt.margin "1 2" --prompt.padding "1 2" --prompt.border double \
    --prompt.align center \
    --default "$(gum style --bold --foreground 124 'EFI System Partition')
Only format the EFI partition if you created it during the partitioning step. \
Reformatting an existing EFI partition will destroy the boot loaders of other installed \
operating systems.
$(gum style --align center --bold --foreground 69 \
'Would you like to format the EFI partition?')" && formatefi="yes" || formatefi="no"
}

get_root_partition() {
  rootpartition=""
  while [ -z "$rootpartition" ]; do
    # choose the name of the root partition
    rootpartition=$(lsblk -Alpn -o NAME,SIZE,TYPE | grep "${diskname##*/}.*part" | \
      gum filter --prompt.foreground 93 --prompt.bold --prompt "Root partition: " \
        --placeholder "(select the root (/) partition)" | cut -d' ' -f1)
  done
}

suggest_swapfile() {
  # get the size of the RAM in kilobytes
  ramsize=$(grep -om 1 '[0-9]*' < /proc/meminfo)
  # get the ceiling of the RAM size in gigabytes
  ramsize=$(((ramsize + 1000000 - 1) / 1000000))
  if [ "$ramsize" -lt 16 ]; then
    gum confirm --prompt.foreground 99 --prompt.border-foreground 105 --prompt.width 55 \
      --prompt.margin "1 2" --prompt.padding "1 2" --prompt.border thick \
      --prompt.align center --default "This system has ${ramsize}GB of RAM.
A swap file double that size is recommended.
Would you like to create $((ramsize * 2))GB of swap file?" &&
      ramsize=$((ramsize * 2)) || ramsize="0"
  else
    ramsize="0"
  fi
}

input_confirmation() {
  hidden=$(for _ in $(seq 1 ${#password}); do printf '%s' "*"; done)
  gum confirm --prompt.foreground 99 --prompt.border-foreground 105 --prompt.align left \
    --prompt.margin "1 2" --prompt.padding "1 2" --prompt.border rounded \
    --default "$(gum format -t markdown "username|password|hostname|keymap|timezone
-|-|-|-|-
${username}|${hidden}|${hostname}|${keymap}|${timezone}

disk|efi part|format|root part|swap
-|-|-|-|-
${diskname}|${efipartition}|${formatefi}|${rootpartition}|${ramsize} GB

$(gum style --align center --bold --width 60 --foreground 69 \
  'Would you like to make changes?')")"
}

final_prompt() {
  gum confirm --prompt.foreground 99 --prompt.border-foreground 105 --prompt.width 55 \
    --prompt.margin "1 2" --prompt.padding "1 2" --prompt.border rounded \
    --prompt.align center --default "The rest of the process will now be automated.
 Would you like to proceed with the installation? "
}

create_swapfile() {
  # header
  gum style --bold --foreground 99 "Making swapfile"
  # create swapfile and change its permission
  fallocate -l "${1}GiB" /maidswap && chmod 600 /maidswap
  # make the swap and activate it
  arch-chroot /mnt mkswap /maidswap && arch-chroot /mnt swapon /maidswap
  # append the swapfile to the fstab file
  echo "/maidswap none swap defaults 0 0" >> /mnt/etc/fstab
  # print the filesystem table to stdout
  genfstab -U /mnt
}

### START OF THE SCRIPT ###

# just in case, make sure the distribution is Arch Linux
[ "$(lsb_release -is)" = "Arch" ] || end "this installer only works on Arch Linux"

# verify that the system is booted in UEFI mode
[ ! -d /sys/firmware/efi/efivars ] &&
  end "please boot the system in UEFI mode and try again"

# check for the root user
[ "$(id -u)" -eq 0 ] || end "please run this script from the archiso"

# test for an internet connection and install gum
pacman --noconfirm --needed -Sy gum >/dev/null 2>&1 ||
  end "pacman failed, please make sure you have an internet connection"

welcome || end "bye bye"

get_username

get_password

get_hostname

set_keymap || end "something went wrong at set_keymap"

get_timezone || end "something went wrong at get_timezone"

disk_partition || end "something went wrong at disk_partition"

get_efi_partition || end "something went wrong at get_efi_partition"

get_root_partition || end "something went wrong at get_root_partition"

# get_home_partition || end "something went wrong at get_home_partition"

suggest_swapfile || end "something went wrong at suggest_swapfile"

while input_confirmation; do
  case "$(gum choose "username" "password" "host" \
    "keymap" "timezone" "disk" "efi" "root" "swap")" in
    username)
      get_username ;;
    password)
      get_password ;;
    host)
      get_hostname ;;
    keymap)
      set_keymap ;;
    timezone)
      get_timezone ;;
    disk)
      disk_partition ;;
    efi)
      get_efi_partition ;;
    root)
      get_root_partition ;;
    swap)
      suggest_swapfile ;;
  esac
done

final_prompt || end "exited"

### START INSTALL ###

# header
gum style --bold --foreground 99 "Updating archlinux-keyring"

# refresh archlinux keyring and install reflector if missing
pacman --needed --noconfirm -S archlinux-keyring reflector curl ca-certificates ||
  end "pacman failed, please make sure you have an internet connection"

# header
gum style --bold --foreground 99 "Updating mirrors using reflector"

# update the mirror list using reflector to have the fastest servers
reflector --protocol https --country US --age 12 --latest 45 --fastest 15 \
  --save /etc/pacman.d/mirrorlist >/dev/null 2>&1 && pacman -Sy ||
    printf '%s\n' "reflector failed, skipping..."

### DISK FORMATTING ###

# header
gum style --bold --foreground 99 "Formatting partitions"

# format the partitions
mkfs.ext4 "$rootpartition" && [ "$formatefi" = "yes" ] &&
  mkfs.fat -F 32 "$efipartition" || end "error formatting the partitions"

# mount the partitions
mount "$rootpartition" /mnt && mount --mkdir "$efipartition" /mnt/boot

### CORE PACKAGES ###

# detect cpu vendor
lscpu | grep -Eiq 'id.*amd' && vendor='amd' || vendor='intel'

# header
gum style --bold --foreground 99 "Installing core packages"

# core packages
set -- linux linux-firmware linux-headers base base-devel ${vendor}-ucode
set -- "$@" grub efibootmgr zsh dash git gum reflector networkmanager
set -- "$@" neovim terminus-font curl ca-certificates

n=0 && for pkg in "$@"; do
  # install the core packages
  n=$((n + 1)) && gum spin --spinner line --title "Installating $pkg (${n} / ${#@})" -- \
    pacstrap -K /mnt "$pkg" || printf '%b\n' "\033[31m${pkg}\033[0m failed"
done && shift "${#@}" && unset n msg vendor

echo "Installed all the core packages."

# to allow connecting to the internet on reboot
arch-chroot /mnt systemctl enable NetworkManager
arch-chroot /mnt systemctl stop NetworkManager

### SYSTEM CONFIGURATION ###

# header
gum style --bold --foreground 99 "Generating filesystem table"

# generate a filesystem table (fstab) file using UUID
genfstab -U /mnt >> /mnt/etc/fstab

# print fstab to stdout
genfstab -U /mnt

# create swapfile if recommended
[ "$ramsize" -gt 0 ] && create_swapfile "$ramsize"

# set the time zone
arch-chroot /mnt ln -sf /usr/share/zoneinfo/"$timezone" /etc/localtime

# synchronize the system and hardware clock
arch-chroot /mnt hwclock --systohc

### LOCALE AND KEYMAP ###

# header
gum style --bold --foreground 99 "Generating locale"

# uncomment and generate the needed locales
sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /mnt/etc/locale.gen
sed -i "s/#ja_JP.UTF-8/ja_JP.UTF-8/" /mnt/etc/locale.gen
arch-chroot /mnt locale-gen

# persist the selected keymap and locales
echo "KEYMAP=$keymap" > /mnt/etc/vconsole.conf
echo "LANG=en_US.UTF-8" > /mnt/etc/locale.conf

### NETWORK CONFIGURATION ###

# create the hostname file
echo "$hostname" > /mnt/etc/hostname

# create the local hostname
arch-chroot /mnt tee -a /etc/hosts >/dev/null << EOT
127.0.0.1    localhost
::1          localhost
127.0.1.1    ${hostname}.localdomain $hostname
EOT

### USER ###

# header
gum style --bold --foreground 99 "Creating users"

arch-chroot /mnt useradd -m -s /usr/bin/zsh "$username" &&
  printf '%b\n' "created user \033[32m${username}\033[0m"

# set password for the new user
echo "$username:$password" | arch-chroot /mnt chpasswd ||
  gum style --foreground 161 "error setting the password for ${username}."

# set password for the root user
echo "root:$password" | arch-chroot /mnt chpasswd && unset password verify
printf '%b\n' "created user \033[32mroot\033[0m"

### PACMAN AND MAKEPKG ###

# enable the multilib repository
sed -i '/^#.multilib]$/s/^#//;/^.multilib]$/{n;s/^#//}' /mnt/etc/pacman.conf

# configure pacman misc options
sed -i '/^#Color/s/^#//;/^#ILoveCandy/s/^#//;/^#ParallelDownloads/s/^#//' /mnt/etc/pacman.conf

# use all cores when compiling packages with makepkg
sed -i "/^#MAKEFLAGS/s/^#//;s/-j2/-j$(nproc)/" /mnt/etc/makepkg.conf

### USER CONFIGURATION ###

# permit user to sudo with password
echo "%${username} ALL=(ALL:ALL) ALL" > /mnt/etc/sudoers.d/00-"${username}"

# allow some system commands to run without password
echo "%${username} ALL=(ALL:ALL) NOPASSWD: /usr/bin/shutdown,/usr/bin/reboot,/usr/bin/mount,\
  /usr/bin/umount,/usr/bin/pacman --noconfirm -S,/usr/bin/pacman -S,/usr/bin/pacman -Sy,\
  /usr/bin/pacman -Syu" > /mnt/etc/sudoers.d/01-no-password-commands

# set the default editor for visudo
echo "Defaults editor=/usr/bin/nvim" > /mnt/etc/sudoers.d/02-visudo-editor

# permit the wheel group to use doas with password
echo "permit persist keepenv :${username}" > /mnt/etc/doas.conf

# beep begone!
rmmod pcspkr && echo "blacklist pcspkr" > /mnt/etc/modprobe.d/nobeep.conf

### ADDITIONAL CONFIGURATIONS ###

# allow zsh startup files to be sourced from a different location at startup
tee -a /mnt/etc/zsh/zshenv >/dev/null << EOF
for z in zshenv zprofile zshrc; do
  # source in the same order as indicated in zsh(1)
  [ -f "\$HOME/.config/zsh/\$z" ] && source "\$HOME/.config/zsh/\$z"
done && unset z
EOF

# set up the reflector service
tee /mnt/etc/xdg/reflector/reflector.conf >/dev/null << EOF
# reflector configuration file for the systemd service
--protocol https
--country US
--latest 45
--fastest 15
--save /etc/pacman.d/mirrorlist
EOF

# allow reflector to update the mirrorlist periodically (weekly by default)
arch-chroot /mnt systemctl enable reflector.timer
arch-chroot /mnt systemctl stop reflector.timer

### BOOT LOADER ###

# header
gum style --bold --foreground 99 "GRUB"

# install GRUB
arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB

# generate a GRUB configuration file
arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg

### FINALIZE ###

# unmount the partitions
umount /mnt/boot && umount /mnt

# installation complete
gum style --align center --foreground 99 --width 60 --margin "1 2" --padding "1 2" \
  "Installation complete. If there were no error messages, please reboot and login as \
$(printf '%b' "\033[1m${username}\033[22m") or as $(printf '%b' "\033[1mroot\033[22m")."
